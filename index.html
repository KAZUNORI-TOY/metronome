<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>拡張メトロノーム（16分音符修正）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { background:#111; color:#fff; font-family:sans-serif; padding:2rem; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; min-height:100vh; box-sizing:border-box; }
    canvas { background:#222; border-radius:50%; margin-top:1rem; box-shadow:0 0 12px #000; }
    .controls { display:flex; flex-direction:column; gap:1rem; min-width:320px; margin-top:2rem; align-items:center; }
    .bpm-controls { display:flex; align-items:center; gap:0.5rem; margin-bottom:1rem; justify-content:center; }
    .bpm-controls button { width:2rem; height:2rem; cursor:pointer; background:#444; border:none; border-radius:4px; color:#eee; font-weight:bold; font-size:1.2rem; transition:background 0.3s; }
    .bpm-controls button:hover { background:#ffaa00; color:#111; }
    .bpm-controls label { font-weight:bold; user-select:none; }
    .section-control { display:flex; flex-direction:column; gap:0.3rem; background:#222; padding:0.5rem 0.8rem; border-radius:6px; }
    .section-control > div { display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap; }
    .section-btn { min-width:90px; cursor:pointer; background:#444; border:none; color:#eee; border-radius:4px; font-weight:bold; transition:background 0.3s; user-select:none; padding:0.3rem 0.6rem; }
    .section-btn.selected, .section-btn:hover { background:#ffaa00; color:#111; }
    label { white-space:nowrap; user-select:none; font-size:0.95rem; }
    select { background:#333; border:none; color:#eee; border-radius:4px; padding:0.25rem 0.5rem; font-size:0.95rem; min-width:80px; cursor:pointer; transition:background 0.3s; }
    select:hover { background:#555; }
    #startStop { margin-top:1rem; cursor:pointer; font-weight:bold; font-size:1rem; padding:0.5rem 1rem; border-radius:6px; background:#444; border:none; color:#eee; transition:background 0.3s; }
    #startStop:hover { background:#ffaa00; color:#111; }
  </style>
</head>
<body>
  <canvas id="metronome" width="400" height="400"></canvas>
  <div class="controls">
    <div class="bpm-controls">
      <label for="bpm-value">BPM:</label>
      <button id="bpm-down">−</button>
      <span id="bpm-value">60</span>
      <button id="bpm-up">＋</button>
    </div>
    <div id="section-wrapper"></div>
    <button id="startStop">スタート</button>
  </div>
  <script>
    const canvas = document.getElementById("metronome");
    const ctx = canvas.getContext("2d");
    const bpmUpBtn = document.getElementById("bpm-up");
    const bpmDownBtn = document.getElementById("bpm-down");
    const bpmValue = document.getElementById("bpm-value");
    const startStopBtn = document.getElementById("startStop");
    const sectionWrapper = document.getElementById("section-wrapper");

    let audioCtx = null, running = false, angle = -Math.PI / 2, lastTime = 0;
    let bpm = 60, rotationSpeed = 2 * Math.PI * bpm / 60;
    let currentSetIndex = 0, triggerAngles = [], secondTriggerAngles = [], clickCount = 0;
    let settingsSequence = Array.from({ length: 8 }, () => ({ subdivision: 2, secondSubdivision: 0, measures: 4 }));

    function createSectionUI() {
      sectionWrapper.innerHTML = "";
      const rhythmOptions = ["なし", "4分音符", "8分音符", "3連符", "16分音符", "5連符", "6連符"];
      settingsSequence.forEach((s, i) => {
        const sc = document.createElement("div");
        sc.className = "section-control";
        const roman = "ⅠⅡⅢⅣⅤⅥⅦⅧ"[i];
        sc.innerHTML = `<button class="section-btn">${roman} セクション</button>
          <div>
            <label>小節数:<select class="measure-select">${[...Array(9).keys()].map(n => `<option value="${n}"${n === s.measures ? " selected" : ""}>${n}</option>`).join("")}</select></label>
            <label>リズム:<select class="subdivision-select">${rhythmOptions.map((label, idx) => `<option value="${idx}"${idx === s.subdivision ? " selected" : ""}>${label}</option>`).join("")}</select></label>
            <label>第2リズム:<select class="second-subdivision-select">${rhythmOptions.map((label, idx) => `<option value="${idx}"${idx === s.secondSubdivision ? " selected" : ""}>${label}</option>`).join("")}</select></label>
          </div>`;
        sectionWrapper.appendChild(sc);
      });
    }

    function updateUIForSet(i) {
      document.querySelectorAll(".section-btn").forEach(b => b.classList.remove("selected"));
      const btn = document.querySelectorAll(".section-btn")[i];
      if (btn) btn.classList.add("selected");
    }

    function getSubdivisionValue(index) {
      const values = [0, 1, 2, 3, 4, 5, 6];
      const map = [0, 1, 2, 3, 4, 5, 6];
      return [0, 1, 2, 3, 4, 5, 6][index];
    }

    function subdivisionToCount(subdivision) {
      return [0, 1, 2, 3, 4, 5, 6][subdivision] === 0 ? 0 : [1, 2, 3, 4, 5, 6][subdivision];
    }

    function getCount(subdivision) {
      return [0, 1, 2, 3, 4, 5, 6][subdivision] === 0 ? 0 : [1, 2, 3, 4, 5, 6][subdivision];
    }

    function applySettings(i) {
      const s = settingsSequence[i];
      subdivision = [0, 1, 2, 3, 4, 5, 6][s.subdivision] || 1;
      secondSubdivision = [0, 1, 2, 3, 4, 5, 6][s.secondSubdivision] || 0;
      rotationSpeed = 2 * Math.PI * bpm / 60;
      triggerAngles = Array.from({ length: subdivision }, (_, j) => ({
        angle: 2 * Math.PI * (j / subdivision) - Math.PI / 2,
        triggered: false
      }));
      secondTriggerAngles = Array.from({ length: secondSubdivision }, (_, j) => ({
        angle: 2 * Math.PI * (j / secondSubdivision) - Math.PI / 2,
        triggered: false
      }));
      draw();
    }

    function playClick(isAccent, isSecond = false) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.type = "sine";
      osc.frequency.setValueAtTime(isSecond ? (isAccent ? 800 : 400) : (isAccent ? 1000 : 600), audioCtx.currentTime);
      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
      osc.start(audioCtx.currentTime); osc.stop(audioCtx.currentTime + 0.1);
    }

    function angleDiff(a, b) {
      return Math.abs(Math.atan2(Math.sin(a - b), Math.cos(a - b)));
    }

    function draw(flashIndex = -1, secondFlashIndex = -1) {
      const cx = canvas.width / 2, cy = canvas.height / 2, rOuter = 150, rInner = 115;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      triggerAngles.forEach((t, i) => {
        const mx = cx + rOuter * Math.cos(t.angle), my = cy + rOuter * Math.sin(t.angle);
        ctx.beginPath(); ctx.arc(mx, my, 8, 0, 2 * Math.PI);
        ctx.fillStyle = (i === flashIndex ? "red" : "#ccbb33");
        ctx.shadowColor = (i === flashIndex ? "red" : "transparent"); ctx.shadowBlur = (i === flashIndex ? 15 : 0); ctx.fill();
      });
      secondTriggerAngles.forEach((t, i) => {
        const mx = cx + rInner * Math.cos(t.angle), my = cy + rInner * Math.sin(t.angle);
        ctx.beginPath(); ctx.arc(mx, my, 8, 0, 2 * Math.PI);
        ctx.fillStyle = (i === secondFlashIndex ? "#0ff" : "#088");
        ctx.shadowColor = (i === secondFlashIndex ? "#0ff" : "transparent"); ctx.shadowBlur = (i === secondFlashIndex ? 10 : 0);
        ctx.fill(); ctx.beginPath(); ctx.arc(mx, my, 2.5, 0, 2 * Math.PI); ctx.fillStyle = "#111"; ctx.fill();
      });
      ctx.beginPath(); ctx.arc(cx, cy, rOuter, 0, 2 * Math.PI); ctx.strokeStyle = "#444"; ctx.lineWidth = 3; ctx.stroke();
      const px = cx + rOuter * Math.cos(angle), py = cy + rOuter * Math.sin(angle);
      ctx.beginPath(); ctx.arc(px, py, 10, 0, 2 * Math.PI);
      ctx.fillStyle = "yellow"; ctx.shadowColor = "yellow"; ctx.shadowBlur = 10; ctx.fill();
      ctx.beginPath(); ctx.arc(cx, cy, 5, 0, 2 * Math.PI); ctx.fillStyle = "#fff"; ctx.fill();
    }

    function loop(time) {
      if (!running) return;
      const dt = (time - lastTime) / 1000; lastTime = time; angle += rotationSpeed * dt;
      if (angle > Math.PI) {
        angle -= 2 * Math.PI;
        triggerAngles.forEach(t => t.triggered = false);
        secondTriggerAngles.forEach(t => t.triggered = false);
      }
      let flashIndex = -1;
      triggerAngles.forEach((t, i) => {
        if (angleDiff(angle, t.angle) < 0.08 && !t.triggered) {
          t.triggered = true; flashIndex = i; playClick(i === 0); clickCount++;
          const measures = settingsSequence[currentSetIndex].measures;
          const totalClicks = measures * 4 * subdivision;
          if (clickCount >= totalClicks) {
            clickCount = 0;
            let nextIndex = currentSetIndex;
            do {
              nextIndex = (nextIndex + 1) % settingsSequence.length;
            } while (settingsSequence[nextIndex].measures === 0);
            currentSetIndex = nextIndex;
            applySettings(currentSetIndex);
            updateUIForSet(currentSetIndex);
          }
        }
      });
      let secondFlashIndex = -1;
      secondTriggerAngles.forEach((t, i) => {
        if (angleDiff(angle, t.angle) < 0.08 && !t.triggered) {
          t.triggered = true; secondFlashIndex = i; playClick(i === 0, true);
        }
      });
      draw(flashIndex, secondFlashIndex); requestAnimationFrame(loop);
    }

    bpmUpBtn.onclick = () => { if (bpm < 300) bpm++; updateBPMDisplay(); };
    bpmDownBtn.onclick = () => { if (bpm > 20) bpm--; updateBPMDisplay(); };
    function updateBPMDisplay() { bpmValue.textContent = bpm; rotationSpeed = 2 * Math.PI * bpm / 60; }

    startStopBtn.onclick = async () => {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") await audioCtx.resume();
      running = !running; startStopBtn.textContent = running ? "ストップ" : "スタート";
      if (running) {
        lastTime = performance.now(); angle = -Math.PI / 2; clickCount = 0; currentSetIndex = 0;
        while (settingsSequence[currentSetIndex].measures === 0)
          currentSetIndex = (currentSetIndex + 1) % settingsSequence.length;
        applySettings(currentSetIndex); updateUIForSet(currentSetIndex); requestAnimationFrame(loop);
      }
    };

    createSectionUI();
    document.querySelectorAll(".subdivision-select").forEach((sel, i) => sel.onchange = e => {
      settingsSequence[i].subdivision = parseInt(e.target.value);
      if (i === currentSetIndex) applySettings(currentSetIndex);
    });
    document.querySelectorAll(".second-subdivision-select").forEach((sel, i) => sel.onchange = e => {
      settingsSequence[i].secondSubdivision = parseInt(e.target.value);
      if (i === currentSetIndex) applySettings(currentSetIndex);
    });
    document.querySelectorAll(".measure-select").forEach((sel, i) => sel.onchange = e => {
      settingsSequence[i].measures = parseInt(e.target.value);
    });
    document.querySelectorAll(".section-btn").forEach((btn, i) => btn.onclick = () => {
      currentSetIndex = i; clickCount = 0; applySettings(currentSetIndex); updateUIForSet(currentSetIndex);
    });

    applySettings(currentSetIndex); updateBPMDisplay(); draw();
  </script>
</body>
</html>
